""" This module implements the class :class:`.Record`, which serves as the internal representation of all data generated
by procedures after calls to :meth:`spherexlabtools.procedures.Procedure.emit`.

"""
import logging
import threading
import numpy as np
import pandas as pd
from pyqtgraph.parametertree import Parameter

import spherexlabtools.log as slt_log
from spherexlabtools.ui import get_object_parameters

log_name = f"{slt_log.LOGGER_NAME}.{__name__.split('.')[-1]}"
logger = logging.getLogger(log_name)


class Record:
    """ The fundamental internal representation of all data generated by procedures after calls to
    :meth:`spherexlabtools.procedures.Procedure.emit`. Records separate data, metadata, and procedure parameters into
    three separate attributes that are updated with the :meth:`.Record.update` method. Thread-safe attribute access
    is also implemented given that Records are often processed by a Viewer and a Recorder, each of which is running
    on a separate thread.
    """

    lock = threading.Lock()
    lock_initialized = True

    def __init__(self, name, viewer=None, recorder=None, **kwargs):
        """ Initialize a record.

        :param name: String identifying the record.
        :param viewer: String identifying the viewer associated with this record.
        :param recorder: String identifying the recorder associated with this record.
        """
        self.name = name
        self.data = None
        self.timestamp = None
        self.proc_params = None
        self.meta = None
        self.procedure_start_time = None
        self.emit_kwargs = None
        self.to_date = False

        # - set the viewer and recorder parameter names - #
        viewer_name = 'None' if viewer is None else viewer.name
        rec_name = 'None' if recorder is None else recorder.name
        self.viewer = Parameter.create(name='Viewer', type='str', value=viewer_name, enabled=False,
                                       children=get_object_parameters(viewer))
        self.recorder = Parameter.create(name='Recorder', type='str', value=rec_name, enabled=False,
                                         children=get_object_parameters(recorder))

    def update(self, data, proc_params=None, meta=None, proc_start_time=None, **kwargs):
        """ This method updates the core attributes of a given record. Data, procedure parameters and metadata are all
        converted into pandas dataframes in the following manner:

        |    1. If the passed in data is a numpy array a dataframe is created matching the shape of the numpy array with
             column names 'self.name_i' where self.name is the string name of the record and i is replaced with the
             column number.

             2. If the passed in data is a dictionary, it is converted to a dataframe with an index generated based on
             the length of the dictionary values. Note that every value of a passed in dictionary must be of the same
             shape.

             3. Otherwise, if the passed in data is neither 1 or 2 and it is **not** a dataframe already, it is converted
             with pd.DataFrame({self.name: data}, index=[0]}.

             4. Finally, if the data is already a dataframe, no conversion is performed.

        :param data: The data generated by a procedure.
        :param proc_params: The parameters of the procedure which generated the data.
        :param meta: Additional metadata of the measurement that should be associated with the data and procedure
                     parameters.
        :param proc_start_time: Timestamp of when the procedure started.

        """
        # - update the dataframe attributes - #
        self.data = self.to_dataframe(data)
        self.proc_params = self.to_dataframe(proc_params)
        self.meta = self.to_dataframe(meta)

        # - update other attributes - #
        self.procedure_start_time = proc_start_time
        self.emit_kwargs = kwargs

        # - set the up-to-date flag - #
        self.to_date = True

    def to_dataframe(self, obj):
        """ Convert the object to a dataframe.

        :param obj: The object to convert to a dataframe.
        :return: Converted dataframe.
        """
        dtype = type(obj)
        if dtype is np.ndarray:
            obj_dict = {
                "_".join([self.name, str(i)]): obj[:, i] for i in range(obj.shape[1])
            }
            df = pd.DataFrame(obj_dict)

        # - special handling for dictionaries since they can hold multidimensional data - #
        elif dtype is dict and len(obj.values()) > 0:
            val0 = list(obj.values())[0]
            val_length = 1 if not hasattr(val0, '__iter__') else len(val0)
            index = np.arange(val_length)

            # - flatten dictionary w/ multidimensional data inputs - #
            to_df_dict = {}
            for param, data in obj.items():
                data_arr = np.array(data)
                if data_arr.size > 1:
                    update_dict = {'_'.join([param, str(i)]): data[:, i] for i in range(data.shape[1])}
                else:
                    update_dict = {param: data}
                to_df_dict.update(update_dict)
            df = pd.DataFrame(to_df_dict, index=index)

        elif dtype is not pd.DataFrame:
            df = pd.DataFrame({self.name: obj}, index=[0])

        else:
            df = obj

        return df

    def __getattribute__(self, name):
        """ Attribute access override for thread safety.
        """
        if not name == "lock" and object.__getattribute__(self, "lock_initialized"):
            with object.__getattribute__(self, "lock"):
                ret = object.__getattribute__(self, name)
        else:
            ret = object.__getattribute__(self, name)

        return ret

    def __setattr__(self, name, value):
        """ Override attribute access for thread safety.
        """
        if not name == "lock" and object.__getattribute__(self, "lock_initialized"):
            with object.__getattribute__(self, "lock"):
                object.__setattr__(self, name, value)

        elif name == "lock" and object.__getattribute__(self, "lock_initialized"):
            raise ValueError("Record lock cannot be modified!")

        else:
            object.__setattr__(self, name, value)
